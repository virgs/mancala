var m=Object.defineProperty;var O=(d,h,l)=>h in d?m(d,h,{enumerable:!0,configurable:!0,writable:!0,value:l}):d[h]=l;var c=(d,h,l)=>(O(d,typeof h!="symbol"?h+"":h,l),l);(function(){"use strict";class d{constructor(e){c(this,"board");c(this,"movesRecord");this.board=[...e],this.movesRecord=[]}getLastIncrementedPitId(){return this.movesRecord[this.movesRecord.length-1].pitId}getPitSeeds(e){return this.board[e]}setPitSeeds(e,t){const s=this.board[e];return this.board[e]=t,this.movesRecord.push({pitId:e,seeds:this.board[e]}),s}getBoard(){return this.board}transferSeeds(e,t){const s=this.board[e];this.setPitSeeds(e,0),this.incrementPitSeeds(t,s)}incrementPitSeeds(e,t=1){return this.setPitSeeds(e,t+this.board[e])}getMovesRecord(){return this.movesRecord}}var h=(a=>(a.TOP="TOP",a.BOTTOM="BOTTOM",a))(h||{});const l=a=>a==="TOP"?"BOTTOM":"TOP";class v{constructor(e){c(this,"boardLength");c(this,"totalStones");this.boardLength=e.length,this.totalStones=e.reduce((t,s)=>t+s,0)}getSideStorePitId(e){return e===h.TOP?this.boardLength/2-1:this.boardLength-1}getOppositeSideStorePitId(e){return e!==h.TOP?this.boardLength/2-1:this.boardLength-1}getOppositeSidePitId(e){return this.boardLength-2-e}isPitStore(e){return e===this.boardLength/2-1||e===this.boardLength-1}checkPitOwnership(e,t){return e===h.TOP&&t<this.boardLength/2||e===h.BOTTOM&&t>=this.boardLength/2}getNextPitId(e){return(e+1)%this.boardLength}}class p{constructor(e){c(this,"playerSide");this.playerSide=e}checkPlayerScore(e){return e[new v(e).getSideStorePitId(this.playerSide)]}checkOppositePlayerScore(e){return e[new v(e).getOppositeSideStorePitId(this.playerSide)]}getAvailableMovesForPlayer(e){const t=new v(e);return e.reduce((s,r,i)=>(t.checkPitOwnership(this.playerSide,i)&&!t.isPitStore(i)&&r>0&&s.push(i),s),[])}getAvailableMovesForOpponentPlayer(e){const t=new v(e);return e.reduce((s,r,i)=>(t.checkPitOwnership(l(this.playerSide),i)&&!t.isPitStore(i)&&r>0&&s.push(i),s),[])}}class P{constructor(e,t){c(this,"staticBoardAnalyser");c(this,"engineSettings");c(this,"movesHistory");this.staticBoardAnalyser=new v(e),this.movesHistory=[],this.engineSettings=t||{}}makeMove(e,t){this.validateMove(e,t);const s=e.playerSide;this.movesHistory.push(e);const r=this.redistributeSeeds(e,t),i=r.getLastIncrementedPitId(),o=this.checkCapture(s,i,r.getBoard()),n=this.checkGameOver(s,o.getBoard());return n?{winningPlayer:n.winningPlayer,nextTurnPlayer:s,boardConfig:n.boardConfig,gameOver:!0,movesRecord:this.engineSettings.recordMoves?r.getMovesRecord().concat(o.getMovesRecord()).concat(n.gameOverMovesRecord):void 0}:{nextTurnPlayer:this.checkNextPlayerTurn(s,i),boardConfig:o.getBoard(),gameOver:!1,movesRecord:this.engineSettings.recordMoves?r.getMovesRecord().concat(o.getMovesRecord()):void 0}}redistributeSeeds(e,t){const s=new d(t);let r=e.pitId,i=s.setPitSeeds(r,0);for(;i>0;)r=this.staticBoardAnalyser.getNextPitId(r),!(this.staticBoardAnalyser.isPitStore(r)&&!this.staticBoardAnalyser.checkPitOwnership(e.playerSide,r))&&(s.incrementPitSeeds(r),--i);return s}getMovesHistory(){return this.movesHistory}checkNextPlayerTurn(e,t){return this.staticBoardAnalyser.checkPitOwnership(e,t)&&this.staticBoardAnalyser.isPitStore(t)?e:l(e)}checkCapture(e,t,s){const r=new d(s);if(this.staticBoardAnalyser.checkPitOwnership(e,t)&&r.getPitSeeds(t)===1&&!this.staticBoardAnalyser.isPitStore(t)){const i=this.staticBoardAnalyser.getOppositeSidePitId(t),o=r.getPitSeeds(i);if(o>0){this.movesHistory.push({playerSide:e,capturedSeeds:o,pitId:i});const n=this.staticBoardAnalyser.getSideStorePitId(e);r.transferSeeds(i,n),r.transferSeeds(t,n)}}return r}validateMove(e,t){if(!this.staticBoardAnalyser.checkPitOwnership(e.playerSide,e.pitId))throw new Error(`Player '${e.playerSide}' cannot select an opponent's pit (${e.pitId})`);if(this.staticBoardAnalyser.isPitStore(e.pitId))throw new Error(`Player '${e.playerSide}' cannot select a store (${e.pitId})`);if(t[e.pitId]===0)throw new Error(`Player '${e.playerSide}' cannot select an empty pit (${e.pitId})`)}checkGameOver(e,t){const s=new p(e);if(s.getAvailableMovesForPlayer(t).length!==0&&s.getAvailableMovesForOpponentPlayer(t).length!==0)return;const r=s.checkPlayerScore(t),i=s.checkOppositePlayerScore(t),o=this.getGameOverMovesRecord(t,e);let n;return r>i?n=e:r<i&&(n=l(e)),{gameOver:!0,boardConfig:o.getBoard(),gameOverMovesRecord:o.getMovesRecord(),winningPlayer:n}}getGameOverMovesRecord(e,t){const s=new d(e);if(this.engineSettings.gameOverCaptureVariation){const r=this.staticBoardAnalyser.getSideStorePitId(t);e.forEach(n=>{this.staticBoardAnalyser.checkPitOwnership(t,n)&&n!==r&&s.transferSeeds(n,r)});const i=l(t),o=this.staticBoardAnalyser.getSideStorePitId(i);e.forEach(n=>{this.staticBoardAnalyser.checkPitOwnership(i,n)&&n!==o&&s.transferSeeds(n,o)})}return s}}var S=(a=>(a[a.EASY=0]="EASY",a[a.MEDIUM=1]="MEDIUM",a[a.HARD=2]="HARD",a))(S||{});Object.keys(S).filter(a=>isNaN(Number(a)));class M{constructor(e,t,s){c(this,"maxDepth");c(this,"aiBainLevel");c(this,"playerSide");c(this,"engine");c(this,"playerMovesAnalyser");c(this,"movesAnalysed");switch(this.aiBainLevel=e,this.movesAnalysed=0,this.playerMovesAnalyser=new p(t),this.engine=new P(s),this.playerSide=t,this.maxDepth=0,e){case S.EASY:this.maxDepth=0;break;case S.MEDIUM:this.maxDepth=2;break;case S.HARD:this.maxDepth=8;break}}async selectBestMove(e){this.movesAnalysed=0;const t=this.playerMovesAnalyser.getAvailableMovesForPlayer(e);let s=t[t.length-1];return t.length>1&&this.maxDepth>0&&t.reduce((r,i)=>{const o=this.engine.makeMove({playerSide:this.playerSide,pitId:i},e),n=this.evaluate(o.boardConfig,0,-1/0,1/0,o.nextTurnPlayer);return n>r&&(r=n,s=i),r},-1/0),s}evaluate(e,t,s,r,i){++this.movesAnalysed;const o=this.playerMovesAnalyser.getAvailableMovesForPlayer(e).length===0||this.playerMovesAnalyser.getAvailableMovesForOpponentPlayer(e).length===0;return t>=this.maxDepth||o||i===void 0?this.playerMovesAnalyser.checkPlayerScore(e)-this.playerMovesAnalyser.checkOppositePlayerScore(e):i===this.playerSide?this.maximize(e,t,s,r):this.minimize(e,t,s,r)}maximize(e,t,s,r){let i=-1/0;const o=this.playerMovesAnalyser.getAvailableMovesForPlayer(e);for(let n of o){const y=this.engine.makeMove({playerSide:this.playerSide,pitId:n},e),u=this.evaluate(y.boardConfig,t+1,s,r,y.nextTurnPlayer);if(i=Math.max(i,u),s=Math.max(s,u),r<=s)break}return i}minimize(e,t,s,r){let i=1/0;const o=this.playerMovesAnalyser.getAvailableMovesForOpponentPlayer(e);for(let n of o){const y=this.engine.makeMove({playerSide:l(this.playerSide),pitId:n},e),u=this.evaluate(y.boardConfig,t+1,s,r,y.nextTurnPlayer);if(i=Math.min(i,u),r=Math.min(r,u),r<=s)break}return i}}let g;self.onmessage=async a=>{const e=a.data,t=JSON.parse(e.boardConfig);g=new M(e.brainLevel,e.playingPlayer,t);const s=await g.selectBestMove(t);self.postMessage({bestPocketIdToPlay:s})}})();
