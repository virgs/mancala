var A=Object.defineProperty;var O=(u,l,p)=>l in u?A(u,l,{enumerable:!0,configurable:!0,writable:!0,value:p}):u[l]=p;var c=(u,l,p)=>(O(u,typeof l!="symbol"?l+"":l,p),p);(function(){"use strict";var u=(i=>(i.TOP="TOP",i.BOTTOM="BOTTOM",i))(u||{});const l=i=>i==="TOP"?"BOTTOM":"TOP";class p{constructor(e){c(this,"boardLength");c(this,"totalStones");this.boardLength=e.length,this.totalStones=e.reduce((t,r)=>t+r,0)}getSideStorePocketIndex(e){return e===u.TOP?this.boardLength/2-1:this.boardLength-1}getOppositeSideStorePocketIndex(e){return e!==u.TOP?this.boardLength/2-1:this.boardLength-1}getOppositeSidePocketIndex(e){return this.boardLength-2-e}isPocketStore(e){return e===this.boardLength/2-1||e===this.boardLength-1}checkPocketOwnership(e,t){return e===u.TOP&&t<this.boardLength/2||e===u.BOTTOM&&t>=this.boardLength/2}getNextPocketId(e){return(e+1)%this.boardLength}}class P{constructor(e){c(this,"playerSide");this.playerSide=e}checkPlayerScore(e){return e[new p(e).getSideStorePocketIndex(this.playerSide)]}checkOppositePlayerScore(e){return e[new p(e).getOppositeSideStorePocketIndex(this.playerSide)]}getAvailableMovesForPlayer(e){const t=new p(e);return e.reduce((r,s,o)=>(t.checkPocketOwnership(this.playerSide,o)&&!t.isPocketStore(o)&&s>0&&r.push(o),r),[])}getAvailableMovesForOpponentPlayer(e){const t=new p(e);return e.reduce((r,s,o)=>(t.checkPocketOwnership(l(this.playerSide),o)&&!t.isPocketStore(o)&&s>0&&r.push(o),r),[])}}class v extends Error{constructor(e){super(e)}}class M{constructor(e,t){c(this,"staticBoardAnalyser");c(this,"engineSettings");c(this,"movesHistory");this.staticBoardAnalyser=new p(e),this.movesHistory=[],this.engineSettings=t||{}}makeMove(e,t){this.validateMove(e,t),this.movesHistory.push(e);const{redistributionMovesRecord:r,currentPocketId:s,boardAfterRedistribution:o}=this.redistributeSeeds(e,t),a=e.playerSide,{captureMovesRecord:n,boardAfterCapture:h}=this.checkCapture(a,s,o),d=this.checkGameOver(a,h);return d.gameOver?{winningPlayer:d.winningPlayer,nextTurnPlayer:a,boardConfig:d.boardConfig,gameOver:!0,movesRecord:this.engineSettings.recordMoves?r.concat(n).concat(d.gameOverMovesRecord):void 0}:{nextTurnPlayer:this.checkNextPlayerTurn(a,s),boardConfig:h,gameOver:!1,movesRecord:this.engineSettings.recordMoves?r.concat(n):void 0}}redistributeSeeds(e,t){const r=[...t];let s=e.pitId,o=r[e.pitId];r[s]=0;const a=[{index:s,seedsAmount:0}];for(;o>0;)s=this.staticBoardAnalyser.getNextPocketId(s),!(this.staticBoardAnalyser.isPocketStore(s)&&!this.staticBoardAnalyser.checkPocketOwnership(e.playerSide,s))&&(++r[s],a.push({index:s,seedsAmount:r[s]}),--o);return{redistributionMovesRecord:a,currentPocketId:s,boardAfterRedistribution:r}}checkNextPlayerTurn(e,t){return this.staticBoardAnalyser.checkPocketOwnership(e,t)&&this.staticBoardAnalyser.isPocketStore(t)?e:l(e)}checkCapture(e,t,r){const s=[...r],o=[];if(this.staticBoardAnalyser.checkPocketOwnership(e,t)&&!this.staticBoardAnalyser.isPocketStore(t)&&s[t]===1){const a=this.staticBoardAnalyser.getOppositeSidePocketIndex(t);if(s[a]>0){const n=this.staticBoardAnalyser.getSideStorePocketIndex(e),h=s[a];s[a]=0,o.push({index:a,seedsAmount:0}),s[n]+=h,o.push({index:n,seedsAmount:s[n]});const d=s[t];s[t]=0,o.push({index:t,seedsAmount:0}),s[n]+=d,o.push({index:n,seedsAmount:s[n]})}}return{captureMovesRecord:o,boardAfterCapture:s}}validateMove(e,t){if(!this.staticBoardAnalyser.checkPocketOwnership(e.playerSide,e.pitId))throw new v(`Player '${e.playerSide}' cannot select an opponent's pocket (${e.pitId})`);if(this.staticBoardAnalyser.isPocketStore(e.pitId))throw new v(`Player '${e.playerSide}' cannot select a store (${e.pitId})`);if(t[e.pitId]===0)throw new v(`Player '${e.playerSide}' cannot select an empty pocket (${e.pitId})`)}checkGameOver(e,t){const r=new P(e);if(r.getAvailableMovesForPlayer(t).length!==0&&r.getAvailableMovesForOpponentPlayer(t).length!==0)return{boardConfig:t,winningPlayer:void 0,gameOverMovesRecord:[],gameOver:!1};const s=l(e),o=this.staticBoardAnalyser.getSideStorePocketIndex(e),a=this.staticBoardAnalyser.getSideStorePocketIndex(s),n=this.getGameOverMovesRecord(t,e);let h;return t[o]>t[a]?h=e:t[o]<t[a]&&(h=s),{gameOver:!0,boardConfig:t,gameOverMovesRecord:n,winningPlayer:h}}getGameOverMovesRecord(e,t){const r=[];if(this.engineSettings.gameOverCaptureVariation){const s=this.staticBoardAnalyser.getSideStorePocketIndex(t);e.forEach(n=>{this.staticBoardAnalyser.checkPocketOwnership(t,n)&&n!==s&&(r.push({index:n,seedsAmount:0}),r.push({index:s,seedsAmount:e[s]+e[n]}),e[s]+=e[n],e[n]=0)});const o=l(t),a=this.staticBoardAnalyser.getSideStorePocketIndex(o);e.forEach(n=>{this.staticBoardAnalyser.checkPocketOwnership(o,n)&&n!==a&&(r.push({index:n,seedsAmount:0}),r.push({index:a,seedsAmount:e[a]+e[n]}),e[a]+=e[n],e[n]=0)})}return r}}var y=(i=>(i[i.BEGINNER=0]="BEGINNER",i[i.MEDIUM=1]="MEDIUM",i[i.HARD=2]="HARD",i[i.HARDCORE=3]="HARDCORE",i))(y||{});class S{constructor(e,t,r){c(this,"maxDepth");c(this,"playerSide");c(this,"engine");c(this,"playerMovesAnalyser");c(this,"movesAnalysed");c(this,"aborted");switch(this.aborted=!1,this.movesAnalysed=0,this.playerMovesAnalyser=new P(t),this.engine=new M(r),this.playerSide=t,this.maxDepth=0,e){case y.BEGINNER:this.maxDepth=0;break;case y.MEDIUM:this.maxDepth=1;break;case y.HARD:this.maxDepth=3;break;case y.HARDCORE:this.maxDepth=9;break}}abort(){this.aborted=!0}async selectBestMove(e){this.movesAnalysed=0,console.log("thinking");const t=this.playerMovesAnalyser.getAvailableMovesForPlayer(e);let r=t[t.length-1];return t.length>1&&this.maxDepth>0&&t.reduce((s,o)=>{const a=this.engine.makeMove({playerSide:this.playerSide,pitId:o},e),n=this.evaluate(a.boardConfig,this.maxDepth,a.nextTurnPlayer);return n>s&&(s=n,r=o),s},-1/0),console.log("done thinking",this.maxDepth,t,r,this.movesAnalysed),[r]}evaluate(e,t,r){++this.movesAnalysed;const s=this.playerMovesAnalyser.getAvailableMovesForPlayer(e).length===0||this.playerMovesAnalyser.getAvailableMovesForOpponentPlayer(e).length===0;return t<=0||s||r===void 0?this.playerMovesAnalyser.checkPlayerScore(e)-this.playerMovesAnalyser.checkOppositePlayerScore(e):r===this.playerSide?this.playerMovesAnalyser.getAvailableMovesForPlayer(e).reduce((n,h)=>{const d=this.engine.makeMove({playerSide:r,pitId:h},e);return Math.max(n,this.evaluate(d.boardConfig,t-1,d.nextTurnPlayer))},-1/0):this.playerMovesAnalyser.getAvailableMovesForOpponentPlayer(e).reduce((n,h)=>{const d=this.engine.makeMove({playerSide:r,pitId:h},e);return Math.min(n,this.evaluate(d.boardConfig,t-1,d.nextTurnPlayer))},1/0)}}let g;self.onmessage=async i=>{if(i.data.abort)g.abort();else{const e=i.data,t=JSON.parse(e.boardConfig);g=new S(e.brainLevel,e.playingPlayer,t);const r=await g.selectBestMove(t);self.postMessage({bestPocketIdToPlay:r})}}})();
