var M=Object.defineProperty;var A=(p,c,d)=>c in p?M(p,c,{enumerable:!0,configurable:!0,writable:!0,value:d}):p[c]=d;var u=(p,c,d)=>(A(p,typeof c!="symbol"?c+"":c,d),d);(function(){"use strict";var p=(i=>(i.TOP="TOP",i.BOTTOM="BOTTOM",i))(p||{});const c=i=>i==="TOP"?"BOTTOM":"TOP";class d{constructor(e){u(this,"boardLength");u(this,"totalStones");this.boardLength=e.length,this.totalStones=e.reduce((t,r)=>t+r,0)}getSideStorePocketIndex(e){return e===p.TOP?this.boardLength/2-1:this.boardLength-1}getOppositeSideStorePocketIndex(e){return e!==p.TOP?this.boardLength/2-1:this.boardLength-1}getOppositeSidePocketIndex(e){return this.boardLength-2-e}isPocketStore(e){return e===this.boardLength/2-1||e===this.boardLength-1}checkPocketOwnership(e,t){return e===p.TOP&&t<this.boardLength/2||e===p.BOTTOM&&t>=this.boardLength/2}getNextPocketId(e){return(e+1)%this.boardLength}}class k{constructor(e){u(this,"playerSide");this.playerSide=e}checkPlayerScore(e){return e[new d(e).getSideStorePocketIndex(this.playerSide)]}checkOppositePlayerScore(e){return e[new d(e).getOppositeSideStorePocketIndex(this.playerSide)]}getAvailableMovesForPlayer(e){const t=new d(e);return e.reduce((r,s,o)=>(t.checkPocketOwnership(this.playerSide,o)&&!t.isPocketStore(o)&&s>0&&r.push(o),r),[])}getAvailableMovesForOpponentPlayer(e){const t=new d(e);return e.reduce((r,s,o)=>(t.checkPocketOwnership(c(this.playerSide),o)&&!t.isPocketStore(o)&&s>0&&r.push(o),r),[])}}class v extends Error{constructor(e){super(e)}}class P{constructor(e,t){u(this,"staticBoardAnalyser");u(this,"engineSettings");this.staticBoardAnalyser=new d(e),this.engineSettings=t||{}}makeMove(e,t){this.validateMove(e,t);const{redistributionMovesRecord:r,currentPocketId:s,boardAfterRedistribution:o}=this.redistributeStones(e,t),a=e.player,{captureMovesRecord:n,boardAfterCapture:l}=this.checkCapture(a,s,o),h=this.checkGameOver(a,l);return h.gameOver?{winningPlayer:h.winningPlayer,nextTurnPlayer:a,boardConfig:h.boardConfig,gameOver:!0,movesRecord:this.engineSettings.recordMoves?r.concat(n).concat(h.gameOverMovesRecord):void 0}:{nextTurnPlayer:this.checkNextPlayerTurn(a,s),boardConfig:l,gameOver:!1,movesRecord:this.engineSettings.recordMoves?r.concat(n):void 0}}redistributeStones(e,t){const r=[...t];let s=e.pocketId,o=r[e.pocketId];r[s]=0;const a=[{index:s,newStonesAmouns:0}];for(;o>0;)s=this.staticBoardAnalyser.getNextPocketId(s),!(this.staticBoardAnalyser.isPocketStore(s)&&!this.staticBoardAnalyser.checkPocketOwnership(e.player,s))&&(++r[s],a.push({index:s,newStonesAmouns:r[s]}),--o);return{redistributionMovesRecord:a,currentPocketId:s,boardAfterRedistribution:r}}checkNextPlayerTurn(e,t){return this.staticBoardAnalyser.checkPocketOwnership(e,t)&&this.staticBoardAnalyser.isPocketStore(t)?e:c(e)}checkCapture(e,t,r){const s=[...r],o=[];if(this.staticBoardAnalyser.checkPocketOwnership(e,t)&&!this.staticBoardAnalyser.isPocketStore(t)&&s[t]===1){const a=this.staticBoardAnalyser.getOppositeSidePocketIndex(t);if(s[a]>0){const n=this.staticBoardAnalyser.getSideStorePocketIndex(e),l=s[a];s[a]=0,o.push({index:a,newStonesAmouns:0}),s[n]+=l,o.push({index:n,newStonesAmouns:s[n]});const h=s[t];s[t]=0,o.push({index:t,newStonesAmouns:0}),s[n]+=h,o.push({index:n,newStonesAmouns:s[n]})}}return{captureMovesRecord:o,boardAfterCapture:s}}validateMove(e,t){if(!this.staticBoardAnalyser.checkPocketOwnership(e.player,e.pocketId))throw new v(`Player '${e.player}' cannot select an opponent's pocket (${e.pocketId})`);if(this.staticBoardAnalyser.isPocketStore(e.pocketId))throw new v(`Player '${e.player}' cannot select a store (${e.pocketId})`);if(t[e.pocketId]===0)throw new v(`Player '${e.player}' cannot select an empty pocket (${e.pocketId})`)}checkGameOver(e,t){const r=new k(e);if(r.getAvailableMovesForPlayer(t).length!==0&&r.getAvailableMovesForOpponentPlayer(t).length!==0)return{boardConfig:t,winningPlayer:void 0,gameOverMovesRecord:[],gameOver:!1};const s=c(e),o=this.staticBoardAnalyser.getSideStorePocketIndex(e),a=this.staticBoardAnalyser.getSideStorePocketIndex(s),n=this.getGameOverMovesRecord(t,e);let l;return t[o]>t[a]?l=e:t[o]<t[a]&&(l=s),{gameOver:!0,boardConfig:t,gameOverMovesRecord:n,winningPlayer:l}}getGameOverMovesRecord(e,t){const r=[];if(this.engineSettings.gameOverCaptureVariation){const s=this.staticBoardAnalyser.getSideStorePocketIndex(t);e.forEach(n=>{this.staticBoardAnalyser.checkPocketOwnership(t,n)&&n!==s&&(r.push({index:n,newStonesAmouns:0}),r.push({index:s,newStonesAmouns:e[s]+e[n]}),e[s]+=e[n],e[n]=0)});const o=c(t),a=this.staticBoardAnalyser.getSideStorePocketIndex(o);e.forEach(n=>{this.staticBoardAnalyser.checkPocketOwnership(o,n)&&n!==a&&(r.push({index:n,newStonesAmouns:0}),r.push({index:a,newStonesAmouns:e[a]+e[n]}),e[a]+=e[n],e[n]=0)})}return r}}var y=(i=>(i[i.BEGINNER=0]="BEGINNER",i[i.MEDIUM=1]="MEDIUM",i[i.HARD=2]="HARD",i[i.HARDCORE=3]="HARDCORE",i))(y||{});class S{constructor(e,t,r){u(this,"maxDepth");u(this,"playerSide");u(this,"engine");u(this,"playerMovesAnalyser");u(this,"movesAnalysed");u(this,"aborted");switch(this.aborted=!1,this.movesAnalysed=0,this.playerMovesAnalyser=new k(t),this.engine=new P(r),this.playerSide=t,this.maxDepth=0,e){case y.BEGINNER:this.maxDepth=0;break;case y.MEDIUM:this.maxDepth=1;break;case y.HARD:this.maxDepth=3;break;case y.HARDCORE:this.maxDepth=9;break}}abort(){this.aborted=!0}async selectBestMove(e){this.movesAnalysed=0,console.log("thinking");const t=this.playerMovesAnalyser.getAvailableMovesForPlayer(e);let r=t[t.length-1];return t.length>1&&this.maxDepth>0&&t.reduce((s,o)=>{const a=this.engine.makeMove({player:this.playerSide,pocketId:o},e),n=this.evaluate(a.boardConfig,this.maxDepth,a.nextTurnPlayer);return n>s&&(s=n,r=o),s},-1/0),console.log("done thinking",this.maxDepth,t,r,this.movesAnalysed),[r]}evaluate(e,t,r){++this.movesAnalysed;const s=this.playerMovesAnalyser.getAvailableMovesForPlayer(e).length===0||this.playerMovesAnalyser.getAvailableMovesForOpponentPlayer(e).length===0;return t<=0||s||r===void 0?this.playerMovesAnalyser.checkPlayerScore(e)-this.playerMovesAnalyser.checkOppositePlayerScore(e):r===this.playerSide?this.playerMovesAnalyser.getAvailableMovesForPlayer(e).reduce((n,l)=>{const h=this.engine.makeMove({player:r,pocketId:l},e);return Math.max(n,this.evaluate(h.boardConfig,t-1,h.nextTurnPlayer))},-1/0):this.playerMovesAnalyser.getAvailableMovesForOpponentPlayer(e).reduce((n,l)=>{const h=this.engine.makeMove({player:r,pocketId:l},e);return Math.min(n,this.evaluate(h.boardConfig,t-1,h.nextTurnPlayer))},1/0)}}let g;self.onmessage=async i=>{if(i.data.abort)g.abort();else{const e=i.data,t=JSON.parse(e.boardConfig);g=new S(e.brainLevel,e.playingPlayer,t);const r=await g.selectBestMove(t);self.postMessage({bestPocketIdToPlay:r})}}})();
