var m=Object.defineProperty;var O=(d,h,l)=>h in d?m(d,h,{enumerable:!0,configurable:!0,writable:!0,value:l}):d[h]=l;var c=(d,h,l)=>(O(d,typeof h!="symbol"?h+"":h,l),l);(function(){"use strict";class d{constructor(e){c(this,"board");c(this,"movesRecord");this.board=[...e],this.movesRecord=[]}getLastIncrementedPitId(){return this.movesRecord[this.movesRecord.length-1].pitId}getPitSeeds(e){return this.board[e]}setPitSeeds(e,t){const s=this.board[e];return this.board[e]=t,this.movesRecord.push({pitId:e,seeds:this.board[e]}),s}getBoard(){return this.board}transferSeeds(e,t){const s=this.board[e];this.setPitSeeds(e,0),this.incrementPitSeeds(t,s)}incrementPitSeeds(e,t=1){return this.setPitSeeds(e,t+this.board[e])}getMovesRecord(){return this.movesRecord}}var h=(o=>(o.TOP="TOP",o.BOTTOM="BOTTOM",o))(h||{});const l=o=>o==="TOP"?"BOTTOM":"TOP";class g{constructor(e){c(this,"boardLength");c(this,"totalStones");this.boardLength=e.length,this.totalStones=e.reduce((t,s)=>t+s,0)}getSideStorePitId(e){return e===h.TOP?this.boardLength/2-1:this.boardLength-1}getOppositeSideStorePitId(e){return e!==h.TOP?this.boardLength/2-1:this.boardLength-1}getOppositeSidePitId(e){return this.boardLength-2-e}isPitStore(e){return e===this.boardLength/2-1||e===this.boardLength-1}checkPitOwnership(e,t){return e===h.TOP&&t<this.boardLength/2||e===h.BOTTOM&&t>=this.boardLength/2}getNextPitId(e){return(e+1)%this.boardLength}}class u{constructor(e){c(this,"playerSide");this.playerSide=e}checkPlayerScore(e){return e[new g(e).getSideStorePitId(this.playerSide)]}checkOppositePlayerScore(e){return e[new g(e).getOppositeSideStorePitId(this.playerSide)]}getAvailableMovesForPlayer(e){const t=new g(e);return e.reduce((s,r,i)=>(t.checkPitOwnership(this.playerSide,i)&&!t.isPitStore(i)&&r>0&&s.push(i),s),[])}getAvailableMovesForOpponentPlayer(e){const t=new g(e);return e.reduce((s,r,i)=>(t.checkPitOwnership(l(this.playerSide),i)&&!t.isPitStore(i)&&r>0&&s.push(i),s),[])}}class P{constructor(e,t){c(this,"staticBoardAnalyser");c(this,"engineSettings");c(this,"movesHistory");this.staticBoardAnalyser=new g(e),this.movesHistory=[],this.engineSettings=t||{}}makeMove(e,t){this.validateMove(e,t);const s=e.playerSide;this.movesHistory.push(e);const r=this.redistributeSeeds(e,t),i=r.getLastIncrementedPitId(),a=this.checkCapture(s,i,r.getBoard()),n=this.checkGameOver(s,a.getBoard());return n?{winningPlayer:n.winningPlayer,nextTurnPlayer:s,boardConfig:n.boardConfig,gameOver:!0,movesRecord:this.engineSettings.recordMoves?r.getMovesRecord().concat(a.getMovesRecord()).concat(n.gameOverMovesRecord):void 0}:{nextTurnPlayer:this.checkNextPlayerTurn(s,i),boardConfig:a.getBoard(),gameOver:!1,movesRecord:this.engineSettings.recordMoves?r.getMovesRecord().concat(a.getMovesRecord()):void 0}}redistributeSeeds(e,t){const s=new d(t);let r=e.pitId,i=s.setPitSeeds(r,0);for(;i>0;)r=this.staticBoardAnalyser.getNextPitId(r),!(this.staticBoardAnalyser.isPitStore(r)&&!this.staticBoardAnalyser.checkPitOwnership(e.playerSide,r))&&(s.incrementPitSeeds(r),--i);return s}getMovesHistory(){return this.movesHistory}checkNextPlayerTurn(e,t){return this.staticBoardAnalyser.checkPitOwnership(e,t)&&this.staticBoardAnalyser.isPitStore(t)?e:l(e)}checkCapture(e,t,s){const r=new d(s);if(this.staticBoardAnalyser.checkPitOwnership(e,t)&&r.getPitSeeds(t)===1&&!this.staticBoardAnalyser.isPitStore(t)){const i=this.staticBoardAnalyser.getOppositeSidePitId(t),a=r.getPitSeeds(i);if(a>0){this.movesHistory.push({playerSide:e,capturedSeeds:a,pitId:i});const n=this.staticBoardAnalyser.getSideStorePitId(e);r.transferSeeds(i,n),r.transferSeeds(t,n)}}return r}validateMove(e,t){if(!this.staticBoardAnalyser.checkPitOwnership(e.playerSide,e.pitId))throw new Error(`Player '${e.playerSide}' cannot select an opponent's pit (${e.pitId})`);if(this.staticBoardAnalyser.isPitStore(e.pitId))throw new Error(`Player '${e.playerSide}' cannot select a store (${e.pitId})`);if(t[e.pitId]===0)throw new Error(`Player '${e.playerSide}' cannot select an empty pit (${e.pitId})`)}checkGameOver(e,t){const s=new u(e);if(s.getAvailableMovesForPlayer(t).length!==0&&s.getAvailableMovesForOpponentPlayer(t).length!==0)return;const r=s.checkPlayerScore(t),i=s.checkOppositePlayerScore(t),a=this.getGameOverMovesRecord(t,e);let n;return r>i?n=e:r<i&&(n=l(e)),{gameOver:!0,boardConfig:a.getBoard(),gameOverMovesRecord:a.getMovesRecord(),winningPlayer:n}}getGameOverMovesRecord(e,t){const s=new d(e);if(this.engineSettings.gameOverCaptureVariation){const r=this.staticBoardAnalyser.getSideStorePitId(t);e.forEach(n=>{this.staticBoardAnalyser.checkPitOwnership(t,n)&&n!==r&&s.transferSeeds(n,r)});const i=l(t),a=this.staticBoardAnalyser.getSideStorePitId(i);e.forEach(n=>{this.staticBoardAnalyser.checkPitOwnership(i,n)&&n!==a&&s.transferSeeds(n,a)})}return s}}var y=(o=>(o[o.BEGINNER=0]="BEGINNER",o[o.MEDIUM=1]="MEDIUM",o[o.HARD=2]="HARD",o[o.HARDCORE=3]="HARDCORE",o))(y||{});Object.keys(y).filter(o=>isNaN(Number(o)));class M{constructor(e,t,s){c(this,"maxDepth");c(this,"aiBainLevel");c(this,"playerSide");c(this,"engine");c(this,"playerMovesAnalyser");c(this,"movesAnalysed");switch(this.aiBainLevel=e,this.movesAnalysed=0,this.playerMovesAnalyser=new u(t),this.engine=new P(s),this.playerSide=t,this.maxDepth=0,e){case y.BEGINNER:this.maxDepth=0;break;case y.MEDIUM:this.maxDepth=1;break;case y.HARD:this.maxDepth=3;break;case y.HARDCORE:this.maxDepth=9;break}}async selectBestMove(e){this.movesAnalysed=0,console.log("thinking");const t=this.playerMovesAnalyser.getAvailableMovesForPlayer(e);let s=t[t.length-1];return t.length>1&&this.maxDepth>0&&t.reduce((r,i)=>{const a=this.engine.makeMove({playerSide:this.playerSide,pitId:i},e),n=this.evaluate(a.boardConfig,0,-1/0,1/0,a.nextTurnPlayer);return n>r&&(r=n,s=i),r},-1/0),console.log("done thinking",y[this.aiBainLevel],this.movesAnalysed),s}evaluate(e,t,s,r,i){++this.movesAnalysed;const a=this.playerMovesAnalyser.getAvailableMovesForPlayer(e).length===0||this.playerMovesAnalyser.getAvailableMovesForOpponentPlayer(e).length===0;return t>=this.maxDepth||a||i===void 0?this.playerMovesAnalyser.checkPlayerScore(e)-this.playerMovesAnalyser.checkOppositePlayerScore(e):i===this.playerSide?this.maximize(e,t,s,r):this.minimize(e,t,s,r)}maximize(e,t,s,r){let i=-1/0;const a=this.playerMovesAnalyser.getAvailableMovesForPlayer(e);for(let n of a){const v=this.engine.makeMove({playerSide:this.playerSide,pitId:n},e),p=this.evaluate(v.boardConfig,t+1,s,r,v.nextTurnPlayer);if(i=Math.max(i,p),s=Math.max(s,p),r<=s)break}return i}minimize(e,t,s,r){let i=1/0;const a=this.playerMovesAnalyser.getAvailableMovesForOpponentPlayer(e);for(let n of a){const v=this.engine.makeMove({playerSide:l(this.playerSide),pitId:n},e),p=this.evaluate(v.boardConfig,t+1,s,r,v.nextTurnPlayer);if(i=Math.min(i,p),r=Math.min(r,p),r<=s)break}return i}}let S;self.onmessage=async o=>{const e=o.data,t=JSON.parse(e.boardConfig);S=new M(e.brainLevel,e.playingPlayer,t);const s=await S.selectBestMove(t);self.postMessage({bestPocketIdToPlay:s})}})();
