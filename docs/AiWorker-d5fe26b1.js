var w=Object.defineProperty;var S=(h,c,u)=>c in h?w(h,c,{enumerable:!0,configurable:!0,writable:!0,value:u}):h[c]=u;var l=(h,c,u)=>(S(h,typeof c!="symbol"?c+"":c,u),u);(function(){"use strict";var h=(a=>(a.TOP="TOP",a.BOTTOM="BOTTOM",a))(h||{});const c=a=>a==="TOP"?"BOTTOM":"TOP";class u{constructor(e){l(this,"boardLength");l(this,"totalStones");this.boardLength=e.length,this.totalStones=e.reduce((t,r)=>t+r,0)}getPlayerStorePocketIndex(e){return e===h.TOP?this.boardLength/2-1:this.boardLength-1}isPocketStore(e){return e===this.boardLength/2-1||e===this.boardLength-1}checkPocketOwnership(e,t){return e===h.TOP&&t<this.boardLength/2||e===h.BOTTOM&&t>=this.boardLength/2}getOppositeSidePocketId(e){return this.boardLength-2-e}getNextPocketId(e){return(e+1)%this.boardLength}}class M{constructor(e){l(this,"playerSide");this.playerSide=e}isGameOver(e){return this.getAvailableMovesForPlayer(e).length===0||this.getAvailableMovesForOpponentPlayer(e).length===0}checkPartialResultsForPlayer(e){return e[new u(e).getPlayerStorePocketIndex(this.playerSide)]}getAvailableMovesForPlayer(e){const t=new u(e);return e.reduce((r,s,n)=>(t.checkPocketOwnership(this.playerSide,n)&&!t.isPocketStore(n)&&s>0&&r.push(n),r),[])}getAvailableMovesForOpponentPlayer(e){const t=new u(e);return e.reduce((r,s,n)=>(t.checkPocketOwnership(c(this.playerSide),n)&&!t.isPocketStore(n)&&s>0&&r.push(n),r),[])}}class k extends Error{constructor(e){super(e)}}class A{constructor(e,t){l(this,"staticBoardAnalyser");l(this,"debug");l(this,"recordMoves");this.staticBoardAnalyser=new u(e),this.debug=(t==null?void 0:t.debug)||!1,this.recordMoves=(t==null?void 0:t.recordMoves)||!1}makeMove(e,t){this.debug&&console.log(`Player '${e.player}' selected pocket (${e.pocketId})`),this.validateMove(e,t);const{redistributionMovesRecord:r,currentPocketId:s,boardAfterRedistribution:n}=this.redistributeStones(e,t),o=e.player,{captureMovesRecord:p,boardAfterCapture:i}=this.checkCapture(o,s,n),P=this.checkGameOver(o,i);return P.gameOver?{nextTurnPlayer:o,boardConfig:P.boardConfig,gameOver:!0,movesRecord:this.recordMoves?r.concat(p).concat(P.movesRecord):void 0}:{nextTurnPlayer:this.checkNextPlayerTurn(o,s),boardConfig:i,gameOver:!1,movesRecord:this.recordMoves?r.concat(p):void 0}}redistributeStones(e,t){const r=[...t];let s=e.pocketId,n=r[e.pocketId];r[s]=0;const o=[{index:s,newStonesAmouns:0}];for(;n>0;)s=this.staticBoardAnalyser.getNextPocketId(s),!(this.staticBoardAnalyser.isPocketStore(s)&&!this.staticBoardAnalyser.checkPocketOwnership(e.player,s))&&(++r[s],o.push({index:s,newStonesAmouns:r[s]}),--n);return{redistributionMovesRecord:o,currentPocketId:s,boardAfterRedistribution:r}}checkNextPlayerTurn(e,t){return this.staticBoardAnalyser.checkPocketOwnership(e,t)&&this.staticBoardAnalyser.isPocketStore(t)?e:c(e)}checkCapture(e,t,r){const s=[...r],n=[];if(this.staticBoardAnalyser.checkPocketOwnership(e,t)&&!this.staticBoardAnalyser.isPocketStore(t)&&s[t]===1){const o=this.staticBoardAnalyser.getOppositeSidePocketId(t);this.debug&&console.log(`Player '${e}' move ended on empty pocket (${t})
Capturing pocket (${o}) with ${s[o]} stones`);const p=s[o];s[o]=0,n.push({index:o,newStonesAmouns:0}),s[t]+=p,n.push({index:t,newStonesAmouns:s[t]})}return{captureMovesRecord:n,boardAfterCapture:s}}validateMove(e,t){if(!this.staticBoardAnalyser.checkPocketOwnership(e.player,e.pocketId))throw new k(`Player '${e.player}' cannot select an opponent's pocket (${e.pocketId})`);if(this.staticBoardAnalyser.isPocketStore(e.pocketId))throw new k(`Player '${e.player}' cannot select a store (${e.pocketId})`);if(t[e.pocketId]===0)throw new k(`Player '${e.player}' cannot select an empty pocket (${e.pocketId})`)}checkGameOver(e,t){const r=new M(e);if(!r.isGameOver(t))return{boardConfig:t,winningPlayer:void 0,gameOver:!1,movesRecord:[]};const s=[],n=c(e),o=this.staticBoardAnalyser.getPlayerStorePocketIndex(e);r.getAvailableMovesForPlayer(t).forEach(y=>{s.push({index:y,newStonesAmouns:0}),s.push({index:o,newStonesAmouns:t[o]+t[y]}),t[o]+=t[y],t[y]=0});const i=this.staticBoardAnalyser.getPlayerStorePocketIndex(n);r.getAvailableMovesForOpponentPlayer(t).forEach(y=>{s.push({index:y,newStonesAmouns:0}),s.push({index:i,newStonesAmouns:t[i]+t[y]}),t[i]+=t[y],t[y]=0});let v;return t[o]>t[i]?v=e:t[o]<t[i]&&(v=n),{gameOver:!0,movesRecord:s,boardConfig:t,winningPlayer:v}}}var d=(a=>(a[a.BEGINNER=0]="BEGINNER",a[a.MEDIUM=1]="MEDIUM",a[a.HARD=2]="HARD",a[a.HARDCORE=3]="HARDCORE",a))(d||{});class O{constructor(e,t,r){l(this,"maxDepth");l(this,"playerSide");l(this,"engine");l(this,"playerMovesDetector");l(this,"playsAnalysed");l(this,"aborted");switch(this.aborted=!1,this.playsAnalysed=0,this.playerMovesDetector=new M(t),this.engine=new A(r),this.playerSide=t,this.maxDepth=0,e){case d.BEGINNER:this.maxDepth=0;break;case d.MEDIUM:this.maxDepth=5;break;case d.HARD:this.maxDepth=9;break;case d.HARDCORE:this.maxDepth=50;break}}abort(){this.aborted=!0}async selectBestMove(e){this.playsAnalysed=0,console.log("thinking");const t=this.playerMovesDetector.getAvailableMovesForPlayer(e);let r=t[t.length-1];return console.log("done thinking",this.maxDepth,t,r,this.playsAnalysed),[r]}evaluate(e,t,r){++this.playsAnalysed;const s=this.playerMovesDetector.getAvailableMovesForPlayer(e);return this.playerMovesDetector.isGameOver(e),t<=0||s.length===1?this.playerMovesDetector.checkPartialResultsForPlayer(e):r!==this.playerSide?s.reduce((o,p)=>{const i=this.engine.makeMove({player:r,pocketId:p},e);return Math.min(o,this.evaluate(i.boardConfig,t-1,i.nextTurnPlayer))},1/0):s.reduce((o,p)=>{const i=this.engine.makeMove({player:r,pocketId:p},e);return Math.max(o,this.evaluate(i.boardConfig,t-1,i.nextTurnPlayer))},1/0)}}let g;self.onmessage=async a=>{if(a.data.abort)g.abort();else{const e=a.data,t=JSON.parse(e.boardConfig);g=new O(e.brainLevel,e.playingPlayer,t);const r=await g.selectBestMove(t);self.postMessage({bestPocketIdToPlay:r})}}})();
