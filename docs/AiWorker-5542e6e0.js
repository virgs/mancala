var k=Object.defineProperty;var A=(h,l,d)=>l in h?k(h,l,{enumerable:!0,configurable:!0,writable:!0,value:d}):h[l]=d;var c=(h,l,d)=>(A(h,typeof l!="symbol"?l+"":l,d),d);(function(){"use strict";var h=(o=>(o.TOP="TOP",o.BOTTOM="BOTTOM",o))(h||{});const l=o=>o==="TOP"?"BOTTOM":"TOP";class d{constructor(e){c(this,"boardLength");c(this,"totalStones");this.boardLength=e.length,this.totalStones=e.reduce((t,s)=>t+s,0)}getSideStorePitId(e){return e===h.TOP?this.boardLength/2-1:this.boardLength-1}getOppositeSideStorePitId(e){return e!==h.TOP?this.boardLength/2-1:this.boardLength-1}getOppositeSidePitId(e){return this.boardLength-2-e}isPocketStore(e){return e===this.boardLength/2-1||e===this.boardLength-1}checkPocketOwnership(e,t){return e===h.TOP&&t<this.boardLength/2||e===h.BOTTOM&&t>=this.boardLength/2}getNextPocketId(e){return(e+1)%this.boardLength}}class S{constructor(e){c(this,"playerSide");this.playerSide=e}checkPlayerScore(e){return e[new d(e).getSideStorePitId(this.playerSide)]}checkOppositePlayerScore(e){return e[new d(e).getOppositeSideStorePitId(this.playerSide)]}getAvailableMovesForPlayer(e){const t=new d(e);return e.reduce((s,r,a)=>(t.checkPocketOwnership(this.playerSide,a)&&!t.isPocketStore(a)&&r>0&&s.push(a),s),[])}getAvailableMovesForOpponentPlayer(e){const t=new d(e);return e.reduce((s,r,a)=>(t.checkPocketOwnership(l(this.playerSide),a)&&!t.isPocketStore(a)&&r>0&&s.push(a),s),[])}}class g{constructor(e){c(this,"board");c(this,"movesRecord");this.board=[...e],this.movesRecord=[]}getLastIncrementedPitId(){return this.movesRecord[this.movesRecord.length-1].pitId}getPitSeeds(e){return this.board[e]}setPitSeeds(e,t){const s=this.board[e];return this.board[e]=t,this.movesRecord.push({pitId:e,seeds:this.board[e]}),s}getBoard(){return this.board}transferSeeds(e,t){const s=this.board[e];this.setPitSeeds(e,0),this.incrementPitSeeds(t,s)}incrementPitSeeds(e,t=1){return this.setPitSeeds(e,t+this.board[e])}getMovesRecord(){return this.movesRecord}}class p extends Error{constructor(e){super(e)}}class M{constructor(e,t){c(this,"staticBoardAnalyser");c(this,"engineSettings");c(this,"movesHistory");this.staticBoardAnalyser=new d(e),this.movesHistory=[],this.engineSettings=t||{}}makeMove(e,t){this.validateMove(e,t);const s=e.playerSide;this.movesHistory.push(e);const r=this.redistributeSeeds(e,t),a=r.getLastIncrementedPitId(),n=this.checkCapture(s,a,r.getBoard()),i=this.checkGameOver(s,n.getBoard());return i.gameOver?{winningPlayer:i.winningPlayer,nextTurnPlayer:s,boardConfig:i.boardConfig,gameOver:!0,movesRecord:this.engineSettings.recordMoves?r.getMovesRecord().concat(n.getMovesRecord()).concat(i.gameOverMovesRecord):void 0}:{nextTurnPlayer:this.checkNextPlayerTurn(s,a),boardConfig:n.getBoard(),gameOver:!1,movesRecord:this.engineSettings.recordMoves?r.getMovesRecord().concat(n.getMovesRecord()):void 0}}redistributeSeeds(e,t){const s=new g(t);let r=e.pitId,a=s.setPitSeeds(r,0);for(;a>0;)r=this.staticBoardAnalyser.getNextPocketId(r),!(this.staticBoardAnalyser.isPocketStore(r)&&!this.staticBoardAnalyser.checkPocketOwnership(e.playerSide,r))&&(s.incrementPitSeeds(r),--a);return s}checkNextPlayerTurn(e,t){return this.staticBoardAnalyser.checkPocketOwnership(e,t)&&this.staticBoardAnalyser.isPocketStore(t)?e:l(e)}checkCapture(e,t,s){const r=new g(s);if(this.staticBoardAnalyser.checkPocketOwnership(e,t)&&!this.staticBoardAnalyser.isPocketStore(t)&&r.getPitSeeds(t)===1){const a=this.staticBoardAnalyser.getOppositeSidePitId(t);if(r.getPitSeeds(a)>0){const n=this.staticBoardAnalyser.getSideStorePitId(e);r.transferSeeds(a,n),r.transferSeeds(t,n)}}return r}validateMove(e,t){if(!this.staticBoardAnalyser.checkPocketOwnership(e.playerSide,e.pitId))throw new p(`Player '${e.playerSide}' cannot select an opponent's pocket (${e.pitId})`);if(this.staticBoardAnalyser.isPocketStore(e.pitId))throw new p(`Player '${e.playerSide}' cannot select a store (${e.pitId})`);if(t[e.pitId]===0)throw new p(`Player '${e.playerSide}' cannot select an empty pocket (${e.pitId})`)}checkGameOver(e,t){const s=new S(e);if(s.getAvailableMovesForPlayer(t).length!==0&&s.getAvailableMovesForOpponentPlayer(t).length!==0)return{boardConfig:t,winningPlayer:void 0,gameOverMovesRecord:[],gameOver:!1};const r=l(e),a=this.staticBoardAnalyser.getSideStorePitId(e),n=this.staticBoardAnalyser.getSideStorePitId(r),i=this.getGameOverMovesRecord(t,e);let y;return t[a]>t[n]?y=e:t[a]<t[n]&&(y=r),{gameOver:!0,boardConfig:t,gameOverMovesRecord:i.getMovesRecord(),winningPlayer:y}}getGameOverMovesRecord(e,t){const s=new g(e);if(this.engineSettings.gameOverCaptureVariation){const r=this.staticBoardAnalyser.getSideStorePitId(t);e.forEach(i=>{this.staticBoardAnalyser.checkPocketOwnership(t,i)&&i!==r&&s.transferSeeds(i,r)});const a=l(t),n=this.staticBoardAnalyser.getSideStorePitId(a);e.forEach(i=>{this.staticBoardAnalyser.checkPocketOwnership(a,i)&&i!==n&&s.transferSeeds(i,n)})}return s}}var v=(o=>(o[o.BEGINNER=0]="BEGINNER",o[o.MEDIUM=1]="MEDIUM",o[o.HARD=2]="HARD",o[o.HARDCORE=3]="HARDCORE",o))(v||{});class O{constructor(e,t,s){c(this,"maxDepth");c(this,"playerSide");c(this,"engine");c(this,"playerMovesAnalyser");c(this,"movesAnalysed");c(this,"aborted");switch(this.aborted=!1,this.movesAnalysed=0,this.playerMovesAnalyser=new S(t),this.engine=new M(s),this.playerSide=t,this.maxDepth=0,e){case v.BEGINNER:this.maxDepth=0;break;case v.MEDIUM:this.maxDepth=1;break;case v.HARD:this.maxDepth=3;break;case v.HARDCORE:this.maxDepth=9;break}}abort(){this.aborted=!0}async selectBestMove(e){this.movesAnalysed=0,console.log("thinking");const t=this.playerMovesAnalyser.getAvailableMovesForPlayer(e);let s=t[t.length-1];return t.length>1&&this.maxDepth>0&&t.reduce((r,a)=>{const n=this.engine.makeMove({playerSide:this.playerSide,pitId:a},e),i=this.evaluate(n.boardConfig,this.maxDepth,n.nextTurnPlayer);return i>r&&(r=i,s=a),r},-1/0),console.log("done thinking",this.maxDepth,t,s,this.movesAnalysed),[s]}evaluate(e,t,s){++this.movesAnalysed;const r=this.playerMovesAnalyser.getAvailableMovesForPlayer(e).length===0||this.playerMovesAnalyser.getAvailableMovesForOpponentPlayer(e).length===0;return t<=0||r||s===void 0?this.playerMovesAnalyser.checkPlayerScore(e)-this.playerMovesAnalyser.checkOppositePlayerScore(e):s===this.playerSide?this.playerMovesAnalyser.getAvailableMovesForPlayer(e).reduce((i,y)=>{const u=this.engine.makeMove({playerSide:s,pitId:y},e);return Math.max(i,this.evaluate(u.boardConfig,t-1,u.nextTurnPlayer))},-1/0):this.playerMovesAnalyser.getAvailableMovesForOpponentPlayer(e).reduce((i,y)=>{const u=this.engine.makeMove({playerSide:s,pitId:y},e);return Math.min(i,this.evaluate(u.boardConfig,t-1,u.nextTurnPlayer))},1/0)}}let P;self.onmessage=async o=>{if(o.data.abort)P.abort();else{const e=o.data,t=JSON.parse(e.boardConfig);P=new O(e.brainLevel,e.playingPlayer,t);const s=await P.selectBestMove(t);self.postMessage({bestPocketIdToPlay:s})}}})();
