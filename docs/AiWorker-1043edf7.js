var M=Object.defineProperty;var m=(l,u,p)=>u in l?M(l,u,{enumerable:!0,configurable:!0,writable:!0,value:p}):l[u]=p;var d=(l,u,p)=>(m(l,typeof u!="symbol"?u+"":u,p),p);(function(){"use strict";var l=(a=>(a.TOP="TOP",a.BOTTOM="BOTTOM",a))(l||{});const u=a=>a==="TOP"?"BOTTOM":"TOP";class p{constructor(e){d(this,"boardLength");d(this,"totalStones");this.boardLength=e.length,this.totalStones=e.reduce((t,r)=>t+r,0)}getPlayerStorePocketIndex(e){return e===l.TOP?this.boardLength/2-1:this.boardLength-1}isPocketStore(e){return e===this.boardLength/2-1||e===this.boardLength-1}checkPocketOwnership(e,t){return e===l.TOP&&t<this.boardLength/2||e===l.BOTTOM&&t>=this.boardLength/2}getOppositeSidePocketId(e){return this.boardLength-2-e}getNextPocketId(e){return(e+1)%this.boardLength}}class g{constructor(e){d(this,"boardConfig");d(this,"staticBoardAnalyser");this.staticBoardAnalyser=new p([...e]),this.boardConfig=[...e]}isGameOver(){if(!(this.getAvailablePlaysForPlayer(l.TOP).length>0||this.getAvailablePlaysForPlayer(l.BOTTOM).length>0))return this.checkPartialResultsForPlayer(l.TOP)?l.TOP:l.BOTTOM}checkPartialResultsForPlayer(e){const t=this.boardConfig[this.staticBoardAnalyser.getPlayerStorePocketIndex(l.TOP)]-this.boardConfig[this.staticBoardAnalyser.getPlayerStorePocketIndex(l.BOTTOM)];return e===l.TOP?t:-t}getAvailablePlaysForPlayer(e){return this.boardConfig.reduce((t,r,s)=>(this.staticBoardAnalyser.checkPocketOwnership(e,s)&&!this.staticBoardAnalyser.isPocketStore(s)&&r>0&&t.push(s),t),[])}}class k extends Error{constructor(e){super(e)}}class b{constructor(e,t){d(this,"staticBoardAnalyser");d(this,"debug");d(this,"lastMovesRecord");this.staticBoardAnalyser=new p(e),this.debug=(t==null?void 0:t.debug)||!1,this.lastMovesRecord=t!=null&&t.recordMoves?[]:void 0}makeMove(e,t){var i;(i=this.lastMovesRecord)==null||i.splice(0,this.lastMovesRecord.length),this.debug&&console.log(`Player '${e.player}' selected pocket (${e.pocketId})`),this.validateAction(e,t);const{currentPocketId:r,boardAfterRedistribution:s}=this.redistributeStones(e,t),{nextPlayerTurn:o,boardAfterCapture:n}=this.checkCapture(e.player,r,s),c=this.checkGameOver(e.player,n);return c||{nextTurnPlayer:o,boardConfig:n,gameOver:!1,movesRecord:this.lastMovesRecord}}redistributeStones(e,t){var n,c;const r=[...t];let s=e.pocketId,o=r[e.pocketId];for(r[s]=0,(n=this.lastMovesRecord)==null||n.push({index:s,newStonesAmouns:0});o>0;)s=this.staticBoardAnalyser.getNextPocketId(s),!(this.staticBoardAnalyser.isPocketStore(s)&&!this.staticBoardAnalyser.checkPocketOwnership(e.player,s))&&(++r[s],(c=this.lastMovesRecord)==null||c.push({index:s,newStonesAmouns:r[s]}),--o);return{currentPocketId:s,boardAfterRedistribution:r}}checkCapture(e,t,r){var n,c;const s=[...r];let o=u(e);if(this.staticBoardAnalyser.checkPocketOwnership(e,t)){if(this.staticBoardAnalyser.isPocketStore(t))o=e;else if(s[t]===1){const i=this.staticBoardAnalyser.getOppositeSidePocketId(t);this.debug&&console.log(`Player '${e}' move ended on empty pocket (${t})
Capturing pocket (${i}) with ${s[i]} stones`);const y=s[i];s[i]=0,(n=this.lastMovesRecord)==null||n.push({index:i,newStonesAmouns:0}),s[t]+=y,(c=this.lastMovesRecord)==null||c.push({index:t,newStonesAmouns:s[t]})}}return{nextPlayerTurn:o,boardAfterCapture:s}}validateAction(e,t){if(!this.staticBoardAnalyser.checkPocketOwnership(e.player,e.pocketId))throw new k(`Player '${e.player}' cannot select an opponent's pocket (${e.pocketId})`);if(this.staticBoardAnalyser.isPocketStore(e.pocketId))throw new k(`Player '${e.player}' cannot select a store (${e.pocketId})`);if(t[e.pocketId]===0)throw new k(`Player '${e.player}' cannot select an empty pocket (${e.pocketId})`)}checkGameOver(e,t){const r=new g(t);if(!r.isGameOver())return;const s=u(e),o=this.staticBoardAnalyser.getPlayerStorePocketIndex(e),n=this.staticBoardAnalyser.getPlayerStorePocketIndex(s);r.getAvailablePlaysForPlayer(e).forEach(h=>{var v,A;(v=this.lastMovesRecord)==null||v.push({index:h,newStonesAmouns:0}),(A=this.lastMovesRecord)==null||A.push({index:o,newStonesAmouns:t[o]+t[h]}),t[o]+=t[h],t[h]=0}),r.getAvailablePlaysForPlayer(s).forEach(h=>{var v,A;(v=this.lastMovesRecord)==null||v.push({index:h,newStonesAmouns:0}),(A=this.lastMovesRecord)==null||A.push({index:n,newStonesAmouns:t[n]+t[h]}),t[n]+=t[h],t[h]=0});let y;return t[o]>t[n]?y=e:t[o]<t[n]&&(y=s),{gameOver:!0,nextTurnPlayer:l.BOTTOM,boardConfig:t,winningPlayer:y,movesRecord:this.lastMovesRecord}}}var P=(a=>(a[a.BEGINNER=0]="BEGINNER",a[a.MEDIUM=1]="MEDIUM",a[a.HARD=2]="HARD",a[a.HARDCORE=3]="HARDCORE",a))(P||{});class f{constructor(e,t,r){d(this,"maxDepth");d(this,"identifier");d(this,"engine");d(this,"playsAnalysed");d(this,"aborted");switch(this.aborted=!1,this.playsAnalysed=0,this.engine=new b(r),this.identifier=t,this.maxDepth=0,e){case P.BEGINNER:this.maxDepth=0;break;case P.MEDIUM:this.maxDepth=5;break;case P.HARD:this.maxDepth=9;break;case P.HARDCORE:this.maxDepth=50;break}}abort(){this.aborted=!0}async selectBestMove(e){this.playsAnalysed=0,console.log("thinking");const r=new g(e).getAvailablePlaysForPlayer(this.identifier);let s=r[Math.floor(Math.random()*r.length)];return r.length>1&&r.reduce((o,n)=>{const c=this.engine.makeMove({player:this.identifier,pocketId:n},e),i=this.evaluate(c.boardConfig,this.maxDepth,c.nextTurnPlayer);return i>o&&(o=i,s=n),o},-1/0),console.log("done thinking",this.maxDepth,r,s,this.playsAnalysed),[s]}evaluate(e,t,r){++this.playsAnalysed;const s=new g(e),o=s.getAvailablePlaysForPlayer(r),n=s.isGameOver();return n?n===r?100:-100:t<=0||n===r||o.length===1?s.checkPartialResultsForPlayer(r):r!==this.identifier?o.reduce((i,y)=>{const h=this.engine.makeMove({player:r,pocketId:y},e);return Math.min(i,this.evaluate(h.boardConfig,t-1,h.nextTurnPlayer))},1/0):o.reduce((i,y)=>{const h=this.engine.makeMove({player:r,pocketId:y},e);return Math.max(i,this.evaluate(h.boardConfig,t-1,h.nextTurnPlayer))},1/0)}}let O;self.onmessage=async a=>{if(a.data.abort)O.abort();else{const e=a.data,t=JSON.parse(e.boardConfig);O=new f(e.brainLevel,e.playingPlayer,t);const r=await O.selectBestMove(t);self.postMessage({bestPocketIdToPlay:r})}}})();
